---
title: "🛠️ 核心原理：Git 狀態機"
subtitle: "為什麼我們不需要資料庫？"
---

## 為什麼不用資料庫？(Git as a State Machine)

傳統的自動化工具高度依賴中央資料庫紀錄進度。但在軟體工廠中，這會面臨 **「狀態與程式碼不同步 (State Drift)」** 的致命問題。

### 唯一的真理：Merge 才是真理 (Single Source of Truth)

我們徹底拋棄了外部資料庫，將狀態機寫死在專案根目錄的 `tracker.json` 中。

::: callout-important
### 流轉機制

1.  **\[領取\]** AI 工人檢查遠端分支。若無人執行，則切換出新分支 `task-{id}`。
2.  **\[宣稱完工\]** AI 完成實作後，在分支內更新 `tracker.json` 將狀態改為 `"completed"` 並提交 PR。
3.  **\[仲裁\]** CI/CD 擔任裁判。通過測試後自動合併，主分支的 `tracker.json` 才會真正更新。測試失敗則主分支進度永遠鎖定。
:::

這形成了一個完美的 **無伺服器防呆機制** 以及 **自動退回 (Rollback) 與重試 (Retry) 機制**。

------------------------------------------------------------------------

## 雙軌制角色 (Dual-Track Architecture)

這座工廠中，AI 被嚴格地分為兩種職位，**絕對不可以互換，也絕對不能混淆大腦**。

### 1. 編排器與啟動組件 (The Orchestrator)

-   **職責**：戰略中心。
-   **改版優化**：現在由 5 個獨立技能組成的 Orchestrator 負責調度。
-   **產出物**：`.antigravity/tracker.json`、強型別規格書與架構決策 (ADR)。

### 2. 工人代理人 (The Worker)

-   **職責**：單軌執行。不准做大決策，照著 Specs 寫程式。
-   **分支即鎖 (Branch-as-Lock)**：遠端分支 `origin/task-{id}` 的存在即代表該任務已被鎖定。領取任務前必須檢查分支存在性。