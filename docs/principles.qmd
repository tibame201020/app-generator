---
title: "🛠️ 核心原理：Git 狀態機"
subtitle: "為什麼我們不需要資料庫？"
---

## 為什麼不用資料庫？(Git as a State Machine)

傳統的自動化工具高度依賴中央資料庫紀錄進度。但在軟體工廠中，這會面臨 **「狀態與程式碼不同步 (State Drift)」** 的致命問題。

### 唯一的真理：Merge 才是真理 (Single Source of Truth)

我們徹底拋棄了外部資料庫，將狀態機寫死在專案根目錄的 `tracker.json` 中。

::: {.callout-important}
### 流轉機制
1. **[領取]** AI 工人切換出新分支 (Branch)。
2. **[宣稱完工]** AI 在該分支將 tracker 中的狀態改為 `"completed"` 並提交 PR。
3. **[仲裁]** 全自動 CI/CD 擔任裁判。測試失敗則主分支 (Main) 狀態永遠停在 `"pending"`。
:::

這形成了一個完美的 **無伺服器防呆機制** 以及 **自動退回 (Rollback) 與重試 (Retry) 機制**。

---

## 雙軌制角色 (Dual-Track Architecture)

這座工廠中，AI 被嚴格地分為兩種職位，**絕對不可以互換，也絕對不能混淆大腦**。

### 1. 編排器與啟動組件 (The Orchestrator)
- **職責**：戰略中心。
- **改版優化**：現在由 5 個獨立技能組成的 Orchestrator 負責調度。
- **產出物**：`tracker.json`、`specs/*.yml` 與 ADR 紀錄。

### 2. 工人代理人 (The Worker)
- **職責**：單軌執行。不准做大決策，照著 Specs 寫程式。
- **分支即鎖 (Branch-as-Lock)**：遠端分支 `origin/task-{id}` 的存在即代表該任務已被鎖定。領取任務前必須檢查分支存在性。
